package mainimport (	"fmt")/*	Creating pointers		Pointer types use an asterisk(*) as a prefix to type pointed to		*int -- a pointer to an integer		Use the addressof operator(&) to get address of variable	Dereferencing pointers		Dereference a pointer by preceding with an asterisk(*)		Complex types (e.g. structs) are automatically dereferenced	Create pointer objects		Can use the addressof operator(&) if value type already exists			ms := myStruct{foo: 42}			p := &ms		Use addressof operator before initializer			&myStruct{foo: 42}		Use the new keyword			Can't initialize fields at the same time	Types with internal pointers		All assignment operations in Go are cop0y operations		Slices and maps contain internal pointers, so copies point to same underlying data*/func main() {	var a int = 42	var b *int = &a  // * pointer to that data type	fmt.Println(a, *b) // * dereference	a = 27	fmt.Println(a, *b)	*b = 14	fmt.Println(a, *b)	pointerArithmetic()	createPointer()	mapSliceHoldingPointer()}func pointerArithmetic() {	// Pointer arithmetic is not possible in golang unlike C language. It raises compilation error.	//m := 1	//n := &m	//n = n + 1	// unsafe package	a := [3]int{1, 2, 3}	b := &a[0]	c := &a[1]	fmt.Printf("%v %p %p\n", a, b, c)	// [1 2 3] 0xc000014150 0xc000014158}type myStruct struct {	foo int}func createPointer() {	var ms *myStruct	// fmt.Println(ms) // <nil>	ms = new(myStruct)	(*ms).foo = 42	// syntax sugar	ms.foo = 42	fmt.Println((*ms).foo)	// syntax sugar	fmt.Println(ms.foo)	// ms = &myStruct{foo: 42}	// ms = new(newStruct)	// fmt.Println(ms)}func mapSliceHoldingPointer() {	a := map[string]string {"foo": "bar", "baz": "buz"}	b := a	fmt.Println(a, b)	// map[baz:buz foo:bar] map[baz:buz foo:bar]	a["foo"] = "qux"	fmt.Println(a, b)	// map[baz:buz foo:qux] map[baz:buz foo:qux]}